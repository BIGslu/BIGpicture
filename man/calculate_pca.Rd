% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculate_pca.R
\name{calculate_pca}
\alias{calculate_pca}
\title{Calculate PCA. Input either voom object or counts and metadata tables}
\usage{
calculate_pca(
  dat = NULL,
  counts = NULL,
  meta = NULL,
  scale = FALSE,
  transform_logCPM = FALSE,
  force = FALSE,
  libraryID = "libID"
)
}
\arguments{
\item{dat}{edgeR DGEList, or limma EList object containing gene counts in libraries. If provided, counts and meta are ignored}

\item{counts}{Data frame or matrix containing gene counts in libraries}

\item{meta}{Data frame or matrix containing meta data with vars. Only needed if using counts, not dat}

\item{scale}{Logical if should scale variance in PCA calculation see stats::prcomp for details. Default is FALSE}

\item{transform_logCPM}{Logical if should convert counts to log counts per million}

\item{force}{If you already ran PCA but want to overwrite previous results set force=TRUE (default is FALSE)}

\item{libraryID}{Character of variable name to match dat meta data frames}
}
\value{
If a voom object is input, returns voom object with $PCA.scaled or $PCA.unscaled slot depending of if scale=TRUE or FALSE
If a data frame or matrix of counts is input, returns a list with slots $counts, $samples, and $PCA.scaled or $PCA.unscaled slot depending of if scale=TRUE or FALSE
}
\description{
Calculate PCA. Input either voom object or counts and metadata tables
}
\examples{
calculate_pca(dat = kimma::example.voom, scale = TRUE)
calculate_pca(counts = kimma::example.count,
              meta = kimma::example.dat$samples,
              transform_logCPM = TRUE)
}
